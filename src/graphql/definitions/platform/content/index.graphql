# import * from 'article.graphql'
# import * from 'company.graphql'
# import * from 'contact.graphql'

type Query {
  platformContent(input: ModelIdInput!): PlatformContent!
}

type PlatformContentStubSidebar {
  body: String
}

type PlatformContentStubLocation {
  latitude: Float
  longitude: Float
}

enum PlatformContentMutation {
  Email
  Magazine
  Website
}

enum PlatformContentType {
  Apparatus
  Article
  Blog
  Collection
  Company
  Contact
  Ebook
  EngineSpec
  Event
  Group
  InQuarters
  Infographic
  Job
  MediaGallery
  News
  Page
  Photostory
  PressRelease
  Product
  ProductExternal
  Promotion
  Review
  Sponsored
  TextAd
  UsedProduct
}

interface PlatformContent {
  # fields directly on platform.model::Content
  id: Int! @value(localField: "_id")
  type: PlatformContentType!
  name(input: PlatformContentNameInput = {}): String @mutatedValue
  shortName: String
  fullName: String # should be calculated in resolvers
  hash: String
  created: Date
  updated: Date
  touched: Date
  published: Date
  unpublished: Date
  createdBy: PlatformSecurityUser @refOne(model: "platform.User")
  updatedBy: PlatformSecurityUser @refOne(model: "platform.User")

  # fields from platform.trait::StatusEnabled
  status: Int

  # fields from platform.trait::Content\BodyFields
  teaser: String
  body: String
  notes: String

  # fields from platform.trait::Taggable
  taxonomy(input: PlatformContentTaxonomyInput = {}): PlatformTaxonomyConnection! @refMany(model: "platform.Taxonomy")

  # fields from platform.trait::ContentRelateable
  relatedTo: [PlatformContent] # add args?

  # fields from platform.trait::MediaRelatable
  primaryImage: PlatformAssetImage @refOne(model: "platform.Asset", criteria: { type: "Image" })
  images(input: PlatformContentImagesInput = {}): PlatformAssetImageConnection! @refMany(model: "platform.Asset", criteria: { type: "Image" })

  # fields from platform.model::Content mutations
  schedules(mutation: PlatformContentMutation = Website): [WebsiteSchedule] # add sort args? change respose to support multiple mutations
  primarySite(input: PlatformContentPrimarySiteInput = {}): WebsiteProductSite @refOne(model: "platform.Product", localField: "mutations.Website.primarySite", criteria: { type: "Site" })
  primarySection(input: PlatformContentPrimarySectionInput = {}): WebsiteSection @refOne(model: "platform.Product", localField: "mutations.Website.primarySection")

  # fields from platform.trait::Content\SeoFields
  seoTitle: String @value(localField: "mutations.Website.seoTitle", fallbackField: "name")
  alias: String @value(localField: "mutations.Website.alias")
  redirects: [String]! @arrayValue(localField: "mutations.Website.redirects")
  slug: String @value(localField: "mutations.Website.slug")
}

input PlatformContentNameInput {
  mutation: PlatformContentMutation = Website
}

input PlatformContentImagesInput {
  sort: PlatformAssetImageSortInput = {}
  pagination: PaginationInput = {}
}

input PlatformContentTaxonomyInput {
  status: ReferenceStatus = active
  sort: PlatformTaxonomySortInput = {}
  pagination: PaginationInput = {}
}

input PlatformContentAuthorableInput {
  status: ReferenceStatus = active
  sort: PlatformContentContactSortInput = {}
  pagination: PaginationInput = {}
}

input PlatformContentPrimarySiteInput {
  status: ReferenceStatus = active
}

input PlatformContentPrimarySectionInput {
  status: ReferenceStatus = active
}
